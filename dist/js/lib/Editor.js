/* src/web/js/lib/Editor.svelte generated by Svelte v3.58.0 */
import {
	SvelteComponent,
	append,
	attr,
	binding_callbacks,
	check_outros,
	component_subscribe,
	create_component,
	destroy_component,
	destroy_each,
	detach,
	element,
	empty,
	group_outros,
	init,
	insert,
	listen,
	mount_component,
	noop,
	run_all,
	safe_not_equal,
	set_data,
	set_store_value,
	space,
	text,
	transition_in,
	transition_out
} from "svelte/internal";

import { router } from 'yrv';
import Icon from './Icon.svelte';
import Ace from './Ace.svelte';
import Toggle from './Toggle.svelte';
import { schemas, current, options, loadFrom } from './gists';

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[33] = list[i];
	return child_ctx;
}

// (192:2) {:else}
function create_else_block(ctx) {
	let div0;
	let t0;
	let current_block_type_index;
	let if_block;
	let t1;
	let div1;
	let ace0;
	let t2;
	let ace1;
	let current;
	let each_value = /*$schemas*/ ctx[7];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const if_block_creators = [create_if_block_1, create_else_block_1];
	const if_blocks = [];

	function select_block_type_3(ctx, dirty) {
		if (/*isAdding*/ ctx[2]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_3(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	ace0 = new Ace({
			props: {
				mode: outputMode,
				value: /*editInput*/ ctx[5]
			}
		});

	ace0.$on("change", /*sync*/ ctx[13]);

	ace1 = new Ace({
			props: {
				mode: outputMode,
				value: /*objectOutput*/ ctx[6],
				readonly: true,
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			div0 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t0 = space();
			if_block.c();
			t1 = space();
			div1 = element("div");
			create_component(ace0.$$.fragment);
			t2 = space();
			create_component(ace1.$$.fragment);
			attr(div0, "class", "flx Tabs");
			attr(div1, "class", "md-flx");
		},
		m(target, anchor) {
			insert(target, div0, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div0, null);
				}
			}

			append(div0, t0);
			if_blocks[current_block_type_index].m(div0, null);
			insert(target, t1, anchor);
			insert(target, div1, anchor);
			mount_component(ace0, div1, null);
			append(div1, t2);
			mount_component(ace1, div1, null);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*remove, $schemas, input, close, update, isEditing, select, $current*/ 3979) {
				each_value = /*$schemas*/ ctx[7];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, t0);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_3(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div0, null);
			}

			const ace0_changes = {};
			if (dirty[0] & /*editInput*/ 32) ace0_changes.value = /*editInput*/ ctx[5];
			ace0.$set(ace0_changes);
			const ace1_changes = {};
			if (dirty[0] & /*objectOutput*/ 64) ace1_changes.value = /*objectOutput*/ ctx[6];

			if (dirty[1] & /*$$scope*/ 32) {
				ace1_changes.$$scope = { dirty, ctx };
			}

			ace1.$set(ace1_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(ace0.$$.fragment, local);
			transition_in(ace1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(ace0.$$.fragment, local);
			transition_out(ace1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div0);
			destroy_each(each_blocks, detaching);
			if_blocks[current_block_type_index].d();
			if (detaching) detach(t1);
			if (detaching) detach(div1);
			destroy_component(ace0);
			destroy_component(ace1);
		}
	};
}

// (190:2) {#if pending}
function create_if_block(ctx) {
	let t;

	return {
		c() {
			t = text("Loading gist...");
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(t);
		}
	};
}

// (204:8) {:else}
function create_else_block_3(ctx) {
	let span;
	let button0;
	let t0_value = /*info*/ ctx[33].filename + "";
	let t0;
	let t1;
	let button1;
	let mounted;
	let dispose;

	function click_handler_1() {
		return /*click_handler_1*/ ctx[19](/*info*/ ctx[33]);
	}

	function click_handler_2() {
		return /*click_handler_2*/ ctx[20](/*info*/ ctx[33]);
	}

	return {
		c() {
			span = element("span");
			button0 = element("button");
			t0 = text(t0_value);
			t1 = space();
			button1 = element("button");
			button1.textContent = "×";
			attr(button1, "class", "nb x-close");
			attr(span, "class", "flx");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, button0);
			append(button0, t0);
			append(span, t1);
			append(span, button1);

			if (!mounted) {
				dispose = [
					listen(button0, "click", click_handler_1),
					listen(button1, "click", click_handler_2)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*$schemas*/ 128 && t0_value !== (t0_value = /*info*/ ctx[33].filename + "")) set_data(t0, t0_value);
		},
		d(detaching) {
			if (detaching) detach(span);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (195:8) {#if $current === info}
function create_if_block_2(ctx) {
	let span;
	let t0;
	let button;
	let mounted;
	let dispose;

	function select_block_type_2(ctx, dirty) {
		if (/*isEditing*/ ctx[3]) return create_if_block_3;
		return create_else_block_2;
	}

	let current_block_type = select_block_type_2(ctx, [-1, -1]);
	let if_block = current_block_type(ctx);

	function click_handler() {
		return /*click_handler*/ ctx[18](/*info*/ ctx[33]);
	}

	return {
		c() {
			span = element("span");
			if_block.c();
			t0 = space();
			button = element("button");
			button.textContent = "×";
			attr(button, "class", "nb x-close");
			attr(span, "class", "sel");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			if_block.m(span, null);
			append(span, t0);
			append(span, button);

			if (!mounted) {
				dispose = listen(button, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (current_block_type === (current_block_type = select_block_type_2(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(span, t0);
				}
			}
		},
		d(detaching) {
			if (detaching) detach(span);
			if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (199:12) {:else}
function create_else_block_2(ctx) {
	let span;
	let t_value = /*info*/ ctx[33].filename + "";
	let t;
	let mounted;
	let dispose;

	function dblclick_handler() {
		return /*dblclick_handler*/ ctx[17](/*info*/ ctx[33]);
	}

	return {
		c() {
			span = element("span");
			t = text(t_value);
			attr(span, "class", "dib");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);

			if (!mounted) {
				dispose = listen(span, "dblclick", dblclick_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*$schemas*/ 128 && t_value !== (t_value = /*info*/ ctx[33].filename + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) detach(span);
			mounted = false;
			dispose();
		}
	};
}

// (197:12) {#if isEditing}
function create_if_block_3(ctx) {
	let input_1;
	let input_1_value_value;
	let mounted;
	let dispose;

	return {
		c() {
			input_1 = element("input");
			attr(input_1, "class", "nb");
			attr(input_1, "type", "text");
			attr(input_1, "spellcheck", "false");
			input_1.value = input_1_value_value = /*info*/ ctx[33].filename;
		},
		m(target, anchor) {
			insert(target, input_1, anchor);
			/*input_1_binding*/ ctx[16](input_1);

			if (!mounted) {
				dispose = [
					listen(input_1, "blur", /*close*/ ctx[8]),
					listen(input_1, "keyup", /*update*/ ctx[11])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*$schemas*/ 128 && input_1_value_value !== (input_1_value_value = /*info*/ ctx[33].filename) && input_1.value !== input_1_value_value) {
				input_1.value = input_1_value_value;
			}
		},
		d(detaching) {
			if (detaching) detach(input_1);
			/*input_1_binding*/ ctx[16](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (194:6) {#each $schemas as info}
function create_each_block(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*$current*/ ctx[0] === /*info*/ ctx[33]) return create_if_block_2;
		return create_else_block_3;
	}

	let current_block_type = select_block_type_1(ctx, [-1, -1]);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
		}
	};
}

// (215:8) {:else}
function create_else_block_1(ctx) {
	let span;
	let button;
	let icon;
	let current;
	let mounted;
	let dispose;
	icon = new Icon({ props: { name: "plus" } });

	return {
		c() {
			span = element("span");
			button = element("button");
			create_component(icon.$$.fragment);
			attr(button, "class", "a nb nbk");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, button);
			mount_component(icon, button, null);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*add*/ ctx[14]);
				mounted = true;
			}
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(span);
			destroy_component(icon);
			mounted = false;
			dispose();
		}
	};
}

// (211:8) {#if isAdding}
function create_if_block_1(ctx) {
	let span;
	let input_1;
	let mounted;
	let dispose;

	return {
		c() {
			span = element("span");
			input_1 = element("input");
			attr(input_1, "class", "nb");
			attr(input_1, "type", "text");
			attr(input_1, "spellcheck", "false");
			attr(span, "class", "sel");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, input_1);
			/*input_1_binding_1*/ ctx[21](input_1);

			if (!mounted) {
				dispose = [
					listen(input_1, "blur", /*close*/ ctx[8]),
					listen(input_1, "keyup", /*submit*/ ctx[12])
				];

				mounted = true;
			}
		},
		p: noop,
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) detach(span);
			/*input_1_binding_1*/ ctx[21](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (229:6) <Ace mode={outputMode} value={objectOutput} readonly>
function create_default_slot(ctx) {
	let span;
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			span = element("span");
			button = element("button");
			button.textContent = "Generate";
			attr(button, "class", "bu");
			attr(span, "class", "abs r0 t0");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, button);

			if (!mounted) {
				dispose = listen(button, "click", /*gen*/ ctx[15]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(span);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let div;
	let current_block_type_index;
	let if_block;
	let current;
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*pending*/ ctx[4]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx, [-1, -1]);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			div = element("div");
			if_block.c();
			attr(div, "class", "nosl");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx, dirty);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(div, null);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(div);
			if_blocks[current_block_type_index].d();
		}
	};
}

let outputMode = 'json';

function validate(e) {
	const isValid = (/^[a-zA-Z0-9_#$%][\w.]*?$/).test(e.target.value);

	if (isValid) {
		e.target.classList.remove('invalid');
		return true;
	}

	if (!e.target.classList.contains('invalid')) {
		e.target.classList.add('invalid');
		return false;
	}
}

function instance($$self, $$props, $$invalidate) {
	let $current;
	let $schemas;
	let $options;
	component_subscribe($$self, current, $$value => $$invalidate(0, $current = $$value));
	component_subscribe($$self, schemas, $$value => $$invalidate(7, $schemas = $$value));
	component_subscribe($$self, options, $$value => $$invalidate(28, $options = $$value));
	const initialLocationHash = window.location.hash;
	let data;
	let input;
	let buffer;
	let selected;
	let isAdding;
	let isEditing;
	let previusURL;
	let value = null;
	let isYAML = false;
	let Encoder = JSON;
	let pending = true;
	let editInput = '{}';
	let objectOutput = '{}';

	function close(e) {
		if (input && (isAdding || isEditing)) {
			if (isAdding) {
				set_store_value(current, $current = selected || $schemas[$schemas.length - 1], $current);
			}

			$$invalidate(2, isAdding = false);
			$$invalidate(3, isEditing = false);
		}
	}

	function select(e, edit) {
		set_store_value(current, $current = selected = e, $current);
		$$invalidate(2, isAdding = false);
		$$invalidate(3, isEditing = !!edit);
		if (edit) setTimeout(() => input.select(), 60);
	}

	function remove(e) {
		if (!confirm(`This action will remove the '${e.filename}' file.\n\nAre you sure?`.trim())) return;
		const offset = $schemas.indexOf(e);
		set_store_value(schemas, $schemas = $schemas.filter(x => x !== e), $schemas);

		if (e.filename === $current.filename) {
			buffer = $$invalidate(5, editInput = '');
			set_store_value(current, $current = null, $current);
		}
	}

	function update(e) {
		if (e.keyCode === 27) close();

		if (validate(e) && e.keyCode === 13) {
			set_store_value(current, $current.filename = e.target.value, $current);
			$$invalidate(3, isEditing = false);
			e.target.value = '';
		}
	}

	function submit(e) {
		if (e.keyCode === 27) close();

		if (validate(e) && e.keyCode === 13) {
			set_store_value(
				schemas,
				$schemas = $schemas.concat({
					filename: e.target.value,
					content: buffer
				}),
				$schemas
			);

			set_store_value(current, $current = $schemas[$schemas.length - 1], $current);
			$$invalidate(2, isAdding = false);
			e.target.value = '';
		}
	}

	// FIXME: how formatting should work?
	// it should not affect current state, just formatting!
	function refresh() {
		try {
			$$invalidate(5, editInput = JSON.stringify(JSON.parse($current.content), null, 2));
		} catch(e) {
			$$invalidate(5, editInput = $current.content); // if (isYAML) {
		} // outputMode = 'json';
	}

	function format(e) {
		value = Encoder.parse($current.content);
		isYAML = e.detail;
		refresh();
	}

	function sync(e) {
		buffer = e.detail;
		if ($current) set_store_value(current, $current.content = buffer, $current);
	}

	function add() {
		buffer = $$invalidate(5, editInput = '');
		selected = $current;
		$$invalidate(2, isAdding = true);
		set_store_value(current, $current = null, $current);
		setTimeout(() => input.focus(), 60);
	}

	function gen() {
		const opts = { ...$options };
		const value = opts.random;
		opts.random = value ? () => value : Math.random;
		let schema = {};
		let refs = [];

		try {
			schema = Encoder.parse($current.content);
			refs = $schemas.map(x => Encoder.parse(x.content));
		} catch(e) {
			
		} // do nothing

		JSONSchemaFaker.option(opts);

		JSONSchemaFaker.resolve(schema, refs).then(result => {
			$$invalidate(6, objectOutput = Encoder.stringify(result, null, 2));
		}).catch(error => alert(error.message));
	}

	router.subscribe(async info => {
		if (!window.location.hash || window.location.hash.match(/^#(options|session)/)) {
			$$invalidate(4, pending = false);
			return;
		}

		if (info.path === previusURL) return;
		previusURL = info.path;
		data = await loadFrom(info.path.substr(1));
		buffer = $$invalidate(5, editInput = '');
		$$invalidate(4, pending = false);
		$$invalidate(2, isAdding = false);
		$$invalidate(3, isEditing = false);

		set_store_value(
			schemas,
			$schemas = Object.keys(data.files).filter(x => ['text/plain', 'application/json'].includes(data.files[x].type)).reduce(
				(prev, cur) => {
					prev.push(data.files[cur]);
					return prev;
				},
				[]
			),
			$schemas
		);

		set_store_value(current, $current = $schemas[0], $current);
	});

	function input_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			input = $$value;
			$$invalidate(1, input);
		});
	}

	const dblclick_handler = info => select(info, true);
	const click_handler = info => remove(info);
	const click_handler_1 = info => select(info);
	const click_handler_2 = info => remove(info);

	function input_1_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			input = $$value;
			$$invalidate(1, input);
		});
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*$current*/ 1) {
			$: if ($current) {
				refresh();
			} else {
				$$invalidate(6, objectOutput = '{}');
				buffer = $$invalidate(5, editInput = '');
				set_store_value(current, $current = { content: '' }, $current);
			}
		}
	};

	return [
		$current,
		input,
		isAdding,
		isEditing,
		pending,
		editInput,
		objectOutput,
		$schemas,
		close,
		select,
		remove,
		update,
		submit,
		sync,
		add,
		gen,
		input_1_binding,
		dblclick_handler,
		click_handler,
		click_handler_1,
		click_handler_2,
		input_1_binding_1
	];
}

class Editor extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {}, null, [-1, -1]);
	}
}

export default Editor;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiRWRpdG9yLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICBpbXBvcnQgeyByb3V0ZXIgfSBmcm9tICd5cnYnO1xuICBpbXBvcnQgSWNvbiBmcm9tICcuL0ljb24uc3ZlbHRlJztcbiAgaW1wb3J0IEFjZSBmcm9tICcuL0FjZS5zdmVsdGUnO1xuICBpbXBvcnQgVG9nZ2xlIGZyb20gJy4vVG9nZ2xlLnN2ZWx0ZSc7XG4gIGltcG9ydCB7IHNjaGVtYXMsIGN1cnJlbnQsIG9wdGlvbnMsIGxvYWRGcm9tIH0gZnJvbSAnLi9naXN0cyc7XG5cbiAgY29uc3QgaW5pdGlhbExvY2F0aW9uSGFzaCA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xuXG4gIGxldCBkYXRhO1xuICBsZXQgaW5wdXQ7XG4gIGxldCBidWZmZXI7XG4gIGxldCBzZWxlY3RlZDtcbiAgbGV0IGlzQWRkaW5nO1xuICBsZXQgaXNFZGl0aW5nO1xuICBsZXQgcHJldml1c1VSTDtcblxuICBsZXQgdmFsdWUgPSBudWxsO1xuICBsZXQgaXNZQU1MID0gZmFsc2U7XG4gIGxldCBFbmNvZGVyID0gSlNPTjtcbiAgbGV0IHBlbmRpbmcgPSB0cnVlO1xuICBsZXQgZWRpdElucHV0ID0gJ3t9JztcbiAgbGV0IG91dHB1dE1vZGUgPSAnanNvbic7XG4gIGxldCBvYmplY3RPdXRwdXQgPSAne30nO1xuXG4gIGZ1bmN0aW9uIGNsb3NlKGUpIHtcbiAgICBpZiAoaW5wdXQgJiYgKGlzQWRkaW5nIHx8IGlzRWRpdGluZykpIHtcbiAgICAgIGlmIChpc0FkZGluZykge1xuICAgICAgICAkY3VycmVudCA9IHNlbGVjdGVkIHx8ICRzY2hlbWFzWyRzY2hlbWFzLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuXG4gICAgICBpc0FkZGluZyA9IGZhbHNlO1xuICAgICAgaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2VsZWN0KGUsIGVkaXQpIHtcbiAgICAkY3VycmVudCA9IHNlbGVjdGVkID0gZTtcbiAgICBpc0FkZGluZyA9IGZhbHNlO1xuICAgIGlzRWRpdGluZyA9ICEhZWRpdDtcblxuICAgIGlmIChlZGl0KSBzZXRUaW1lb3V0KCgpID0+IGlucHV0LnNlbGVjdCgpLCA2MCk7XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmUoZSkge1xuICAgIGlmICghY29uZmlybShgVGhpcyBhY3Rpb24gd2lsbCByZW1vdmUgdGhlICcke2UuZmlsZW5hbWV9JyBmaWxlLlxcblxcbkFyZSB5b3Ugc3VyZT9gLnRyaW0oKSkpIHJldHVybjtcblxuICAgIGNvbnN0IG9mZnNldCA9ICRzY2hlbWFzLmluZGV4T2YoZSk7XG5cbiAgICAkc2NoZW1hcyA9ICRzY2hlbWFzLmZpbHRlcih4ID0+IHggIT09IGUpO1xuXG4gICAgaWYgKGUuZmlsZW5hbWUgPT09ICRjdXJyZW50LmZpbGVuYW1lKSB7XG4gICAgICBidWZmZXIgPSBlZGl0SW5wdXQgPSAnJztcbiAgICAgICRjdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShlKSB7XG4gICAgY29uc3QgaXNWYWxpZCA9IC9eW2EtekEtWjAtOV8jJCVdW1xcdy5dKj8kLy50ZXN0KGUudGFyZ2V0LnZhbHVlKTtcblxuICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICBlLnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdpbnZhbGlkJyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnaW52YWxpZCcpKSB7XG4gICAgICBlLnRhcmdldC5jbGFzc0xpc3QuYWRkKCdpbnZhbGlkJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlKGUpIHtcbiAgICBpZiAoZS5rZXlDb2RlID09PSAyNykgY2xvc2UoKTtcbiAgICBpZiAodmFsaWRhdGUoZSkgJiYgZS5rZXlDb2RlID09PSAxMykge1xuICAgICAgJGN1cnJlbnQuZmlsZW5hbWUgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgIGlzRWRpdGluZyA9IGZhbHNlO1xuICAgICAgZS50YXJnZXQudmFsdWUgPSAnJztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdWJtaXQoZSkge1xuICAgIGlmIChlLmtleUNvZGUgPT09IDI3KSBjbG9zZSgpO1xuICAgIGlmICh2YWxpZGF0ZShlKSAmJiBlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAkc2NoZW1hcyA9ICRzY2hlbWFzLmNvbmNhdCh7IGZpbGVuYW1lOiBlLnRhcmdldC52YWx1ZSwgY29udGVudDogYnVmZmVyIH0pO1xuICAgICAgJGN1cnJlbnQgPSAkc2NoZW1hc1skc2NoZW1hcy5sZW5ndGggLSAxXTtcbiAgICAgIGlzQWRkaW5nID0gZmFsc2U7XG4gICAgICBlLnRhcmdldC52YWx1ZSA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZJWE1FOiBob3cgZm9ybWF0dGluZyBzaG91bGQgd29yaz9cbiAgLy8gaXQgc2hvdWxkIG5vdCBhZmZlY3QgY3VycmVudCBzdGF0ZSwganVzdCBmb3JtYXR0aW5nIVxuICBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgIHRyeSB7XG4gICAgICBlZGl0SW5wdXQgPSBKU09OLnN0cmluZ2lmeShKU09OLnBhcnNlKCRjdXJyZW50LmNvbnRlbnQpLCBudWxsLCAyKTtcbiAgICAgIC8vIGlmIChpc1lBTUwpIHtcbiAgICAgIC8vICAgLy8gb3V0cHV0TW9kZSA9ICd5YW1sJztcbiAgICAgIC8vICAgLy8gRW5jb2RlciA9IFlBTUw7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICBlZGl0SW5wdXQgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgMik7XG4gICAgICAvLyAgIC8vIG91dHB1dE1vZGUgPSAnanNvbic7XG4gICAgICAvLyAgIC8vIEVuY29kZXIgPSBKU09OO1xuICAgICAgLy8gfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVkaXRJbnB1dCA9ICRjdXJyZW50LmNvbnRlbnQ7XG4gICAgICAvLyBvdXRwdXRNb2RlID0gJ2pzb24nO1xuICAgICAgLy8gRW5jb2RlciA9IEpTT047XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZm9ybWF0KGUpIHtcbiAgICB2YWx1ZSA9IEVuY29kZXIucGFyc2UoJGN1cnJlbnQuY29udGVudCk7XG4gICAgaXNZQU1MID0gZS5kZXRhaWw7XG4gICAgcmVmcmVzaCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3luYyhlKSB7XG4gICAgYnVmZmVyID0gZS5kZXRhaWw7XG4gICAgaWYgKCRjdXJyZW50KSAkY3VycmVudC5jb250ZW50ID0gYnVmZmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkKCkge1xuICAgIGJ1ZmZlciA9IGVkaXRJbnB1dCA9ICcnO1xuICAgIHNlbGVjdGVkID0gJGN1cnJlbnQ7XG4gICAgaXNBZGRpbmcgPSB0cnVlO1xuICAgICRjdXJyZW50ID0gbnVsbDtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4gaW5wdXQuZm9jdXMoKSwgNjApO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuKCkge1xuICAgIGNvbnN0IG9wdHMgPSB7IC4uLiRvcHRpb25zIH07XG4gICAgY29uc3QgdmFsdWUgPSBvcHRzLnJhbmRvbTtcblxuICAgIG9wdHMucmFuZG9tID0gdmFsdWVcbiAgICAgID8gKCgpID0+IHZhbHVlKVxuICAgICAgOiBNYXRoLnJhbmRvbTtcblxuICAgIGxldCBzY2hlbWEgPSB7fTtcbiAgICBsZXQgcmVmcyA9IFtdO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNjaGVtYSA9IEVuY29kZXIucGFyc2UoJGN1cnJlbnQuY29udGVudCk7XG4gICAgICByZWZzID0gJHNjaGVtYXMubWFwKHggPT4gRW5jb2Rlci5wYXJzZSh4LmNvbnRlbnQpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxuXG4gICAgSlNPTlNjaGVtYUZha2VyLm9wdGlvbihvcHRzKTtcbiAgICBKU09OU2NoZW1hRmFrZXIucmVzb2x2ZShzY2hlbWEsIHJlZnMpXG4gICAgICAudGhlbihyZXN1bHQgPT4geyBvYmplY3RPdXRwdXQgPSBFbmNvZGVyLnN0cmluZ2lmeShyZXN1bHQsIG51bGwsIDIpOyB9KVxuICAgICAgLmNhdGNoKGVycm9yID0+IGFsZXJ0KGVycm9yLm1lc3NhZ2UpKTtcbiAgfVxuXG4gIHJvdXRlci5zdWJzY3JpYmUoYXN5bmMgaW5mbyA9PiB7XG4gICAgaWYgKCF3aW5kb3cubG9jYXRpb24uaGFzaCB8fCB3aW5kb3cubG9jYXRpb24uaGFzaC5tYXRjaCgvXiMob3B0aW9uc3xzZXNzaW9uKS8pKSB7XG4gICAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGluZm8ucGF0aCA9PT0gcHJldml1c1VSTCkgcmV0dXJuO1xuICAgIHByZXZpdXNVUkwgPSBpbmZvLnBhdGg7XG5cbiAgICBkYXRhID0gYXdhaXQgbG9hZEZyb20oaW5mby5wYXRoLnN1YnN0cigxKSk7XG4gICAgYnVmZmVyID0gZWRpdElucHV0ID0gJyc7XG4gICAgcGVuZGluZyA9IGZhbHNlO1xuICAgIGlzQWRkaW5nID0gZmFsc2U7XG4gICAgaXNFZGl0aW5nID0gZmFsc2U7XG5cbiAgICAkc2NoZW1hcyA9IE9iamVjdC5rZXlzKGRhdGEuZmlsZXMpXG4gICAgICAuZmlsdGVyKHggPT4gWyd0ZXh0L3BsYWluJywgJ2FwcGxpY2F0aW9uL2pzb24nXS5pbmNsdWRlcyhkYXRhLmZpbGVzW3hdLnR5cGUpKVxuICAgICAgLnJlZHVjZSgocHJldiwgY3VyKSA9PiB7XG4gICAgICAgIHByZXYucHVzaChkYXRhLmZpbGVzW2N1cl0pO1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH0sIFtdKTtcblxuICAgICRjdXJyZW50ID0gJHNjaGVtYXNbMF07XG4gIH0pO1xuXG4gICQ6IGlmICgkY3VycmVudCkge1xuICAgIHJlZnJlc2goKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RPdXRwdXQgPSAne30nO1xuICAgIGJ1ZmZlciA9IGVkaXRJbnB1dCA9ICcnO1xuICAgICRjdXJyZW50ID0geyBjb250ZW50OiAnJyB9O1xuICB9XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cIm5vc2xcIj5cbiAgeyNpZiBwZW5kaW5nfVxuICAgIExvYWRpbmcgZ2lzdC4uLlxuICB7OmVsc2V9XG4gICAgPGRpdiBjbGFzcz1cImZseCBUYWJzXCI+XG4gICAgICB7I2VhY2ggJHNjaGVtYXMgYXMgaW5mb31cbiAgICAgICAgeyNpZiAkY3VycmVudCA9PT0gaW5mb31cbiAgICAgICAgICA8c3BhbiBjbGFzcz1cInNlbFwiPlxuICAgICAgICAgICAgeyNpZiBpc0VkaXRpbmd9XG4gICAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cIm5iXCIgb246Ymx1cj17Y2xvc2V9IG9uOmtleXVwPXt1cGRhdGV9IGJpbmQ6dGhpcz17aW5wdXR9IHR5cGU9XCJ0ZXh0XCIgc3BlbGxjaGVjaz1cImZhbHNlXCIgdmFsdWU9e2luZm8uZmlsZW5hbWV9IC8+XG4gICAgICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZGliXCIgb246ZGJsY2xpY2s9eygpID0+IHNlbGVjdChpbmZvLCB0cnVlKX0+e2luZm8uZmlsZW5hbWV9PC9zcGFuPlxuICAgICAgICAgICAgey9pZn1cbiAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJuYiB4LWNsb3NlXCIgb246Y2xpY2s9eygpID0+IHJlbW92ZShpbmZvKX0+JnRpbWVzOzwvYnV0dG9uPlxuICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgezplbHNlfVxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmx4XCI+XG4gICAgICAgICAgICA8YnV0dG9uIG9uOmNsaWNrPXsoKSA9PiBzZWxlY3QoaW5mbyl9PntpbmZvLmZpbGVuYW1lfTwvYnV0dG9uPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cIm5iIHgtY2xvc2VcIiBvbjpjbGljaz17KCkgPT4gcmVtb3ZlKGluZm8pfT4mdGltZXM7PC9idXR0b24+XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICB7L2lmfVxuICAgICAgey9lYWNofVxuICAgICAgICB7I2lmIGlzQWRkaW5nfVxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwic2VsXCI+XG4gICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJuYlwiIG9uOmJsdXI9e2Nsb3NlfSBvbjprZXl1cD17c3VibWl0fSBiaW5kOnRoaXM9e2lucHV0fSB0eXBlPVwidGV4dFwiIHNwZWxsY2hlY2s9XCJmYWxzZVwiIC8+XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICB7OmVsc2V9XG4gICAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYSBuYiBuYmtcIiBvbjpjbGljaz17YWRkfT5cbiAgICAgICAgICAgICAgPEljb24gbmFtZT1cInBsdXNcIiAvPlxuICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICB7L2lmfVxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJtZC1mbHhcIj5cbiAgICAgIDxBY2UgbW9kZT17b3V0cHV0TW9kZX0gdmFsdWU9e2VkaXRJbnB1dH0gb246Y2hhbmdlPXtzeW5jfT5cbiAgICAgICAgPCEtLTxkaXYgY2xhc3M9XCJhYnMgcjAgdDBcIj5cbiAgICAgICAgICA8VG9nZ2xlIG9uPVwiWUFNTFwiIG9mZj1cIkpTT05cIiBvbjpjaGFuZ2U9e2Zvcm1hdH0gdmFsdWU9e2lzWUFNTH0gLz5cbiAgICAgICAgPC9kaXY+LS0+XG4gICAgICA8L0FjZT5cbiAgICAgIDxBY2UgbW9kZT17b3V0cHV0TW9kZX0gdmFsdWU9e29iamVjdE91dHB1dH0gcmVhZG9ubHk+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiYWJzIHIwIHQwXCI+XG4gICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ1XCIgb246Y2xpY2s9e2dlbn0+R2VuZXJhdGU8L2J1dHRvbj5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgPC9BY2U+XG4gICAgPC9kaXY+XG4gIHsvaWZ9XG48L2Rpdj5cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1NBQ1csTUFBTSxRQUFRLEtBQUs7T0FDckIsSUFBSSxNQUFNLGVBQWU7T0FDekIsR0FBRyxNQUFNLGNBQWM7T0FDdkIsTUFBTSxNQUFNLGlCQUFpQjtTQUMzQixPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxRQUFRLFFBQVEsU0FBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K0JBNExsRCxHQUFROzs7Z0NBQWIsTUFBSTs7Ozs7Ozs7bUJBaUJDLEdBQVE7Ozs7Ozs7OztVQWFKLFVBQVU7eUJBQVMsR0FBUzs7Ozs2QkFBYSxHQUFJOzs7O1VBSzdDLFVBQVU7NEJBQVMsR0FBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FwQzVDLE1BNkJNOzs7Ozs7Ozs7OztHQUNOLE1BV007Ozs7Ozs7OzhCQXhDRyxHQUFROzs7K0JBQWIsTUFBSTs7Ozs7Ozs7Ozs7Ozs7OztvQ0FBSixNQUFJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dUVBOEJ3QixHQUFTOzs7NkVBS1QsR0FBWTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBdkNqQyxpQkFFYjs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lCQWNpRCxHQUFJLEtBQUMsUUFBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBRHRELE1BR087R0FGTCxNQUE4RDs7O0dBQzlELE1BQXlFOzs7Ozs7Ozs7Ozs7O3dFQURsQyxHQUFJLEtBQUMsUUFBUTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvQkFUL0MsR0FBUzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQURoQixNQU9POzs7R0FETCxNQUF5RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt3QkFGYixHQUFJLEtBQUMsUUFBUTs7Ozs7Ozs7Ozs7Ozs7OztHQUF2RSxNQUErRTs7Ozs7Ozs7OztzRUFBckIsR0FBSSxLQUFDLFFBQVE7Ozs7Ozs7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